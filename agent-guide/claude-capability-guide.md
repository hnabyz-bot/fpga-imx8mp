# Claude Code 작업 능력 가이드
**FPGA-i.MX8MP MIPI 프로젝트 기준**

---

## 목차
1. [Claude Code 도구 개요](#1-claude-code-도구-개요)
2. [작업 가능 범위](#2-작업-가능-범위)
3. [작업 불가능 범위](#3-작업-불가능-범위)
4. [프로젝트별 작업 매트릭스](#4-프로젝트별-작업-매트릭스)
5. [권장 작업 흐름](#5-권장-작업-흐름)
6. [사용자 준비 사항](#6-사용자-준비-사항)

---

## 1. Claude Code 도구 개요

### 사용 가능한 핵심 도구

| 도구 | 기능 | 사용 예시 |
|------|------|-----------|
| **Read** | 파일 읽기 (코드, 문서, 이미지, PDF) | Verilog 코드 분석, DTS 파일 검토 |
| **Write** | 새 파일 작성 | Verilog 모듈, Python 스크립트 생성 |
| **Edit** | 기존 파일 수정 | 코드 수정, 설정 변경 |
| **Glob** | 파일 패턴 검색 | `**/*.v` (모든 Verilog 파일 찾기) |
| **Grep** | 코드 내용 검색 | `AXI4-Stream` 키워드 검색 |
| **Bash** | 명령어 실행 | git, 파일 조작, 스크립트 실행 |
| **WebSearch** | 웹 검색 | MIPI 스펙 확인, 에러 해결 방법 검색 |
| **TodoWrite** | 작업 추적 | Task 진행 상황 관리 |

### 도구 제약사항

| 제약 | 설명 | 영향 |
|------|------|------|
| **실행 환경** | Windows 환경 (d:\workspace\...) | Linux 전용 명령어 제한적 |
| **하드웨어 접근** | 물리적 장치 제어 불가 | FPGA 프로그래밍, 보드 테스트 불가 |
| **GUI 도구** | Vivado, Qt Creator 등 GUI 불가 | 설정 파일/스크립트만 생성 가능 |
| **실시간 컴파일** | 대용량 빌드 실행 제한 | 빌드 스크립트 제공, 실행은 사용자 |

---

## 2. 작업 가능 범위

### ✅ 2.1 코드 작성 및 설계

#### FPGA 관련
| 작업 | 가능 여부 | 산출물 |
|------|-----------|--------|
| Verilog/VHDL 모듈 작성 | ✅ 가능 | `.v`, `.vhd` 파일 |
| 데이터 변환 로직 설계 | ✅ 가능 | 16-bit → RAW8 패킹 모듈 |
| FSM 설계 | ✅ 가능 | MIPI CSI-2 TX FSM |
| 테스트벤치 작성 | ✅ 가능 | Simulation 코드 |
| TCL 스크립트 작성 | ✅ 가능 | Vivado IP 설정 스크립트 |
| XDC 제약 파일 작성 | ✅ 가능 | 타이밍 제약, 핀 맵핑 |
| **Vivado 프로젝트 빌드** | ❌ 불가능 | 스크립트만 제공 |
| **비트스트림 생성** | ❌ 불가능 | 사용자가 Vivado에서 실행 |
| **ILA 디버깅** | ❌ 불가능 | 분석 방법만 가이드 |

#### i.MX8MP 관련
| 작업 | 가능 여부 | 산출물 |
|------|-----------|--------|
| Device Tree 작성 | ✅ 가능 | `.dts`, `.dtsi` 파일 |
| 드라이버 설정 스크립트 | ✅ 가능 | Bash 스크립트 |
| 커널 설정 분석 | ✅ 가능 | Kconfig 검토 및 권장사항 |
| v4l2 캡처 스크립트 | ✅ 가능 | Bash 스크립트 |
| 메모리 맵 분석 | ✅ 가능 | 문서 및 다이어그램 |
| **커널 컴파일** | ❌ 불가능 | 컴파일 명령어만 제공 |
| **보드 플래싱** | ❌ 불가능 | 사용자가 직접 실행 |
| **실시간 dmesg 모니터링** | ❌ 불가능 | 명령어 및 분석 방법 제공 |

### ✅ 2.2 검증 및 분석

| 작업 | 가능 여부 | 산출물 |
|------|-----------|--------|
| Python 검증 스크립트 | ✅ 가능 | 데이터 무결성 검증 코드 |
| 타이밍 계산 | ✅ 가능 | D-PHY 파라미터 계산 문서 |
| 메모리 정렬 검증 | ✅ 가능 | Stride 계산 및 검증 |
| 프로토콜 분석 | ✅ 가능 | MIPI 패킷 구조 문서 |
| 에러 시나리오 분석 | ✅ 가능 | 디버깅 가이드 |
| 코드 리뷰 | ✅ 가능 | 잠재적 오류 식별 및 해결책 |

### ✅ 2.3 문서화

| 작업 | 가능 여부 | 산출물 |
|------|-----------|--------|
| 기술 문서 작성 | ✅ 가능 | 마크다운, PDF |
| 다이어그램 생성 | ✅ 가능 | ASCII 다이어그램, Mermaid |
| 주석 및 설명 추가 | ✅ 가능 | 코드 주석 |
| 최종 보고서 | ✅ 가능 | 프로젝트 완료 보고서 |

---

## 3. 작업 범위 세부 분류

### 🔍 작업 세분화 기준
각 작업을 **Claude가 직접 수행 가능한 단계**와 **사용자만 수행 가능한 단계**로 구분합니다.

---

### 3.1 FPGA 관련 작업 세분화

#### 📌 Vivado 프로젝트 빌드
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | Vivado 프로젝트 구조 생성 TCL | ✅ 가능 | - | `create_project.tcl` |
| 2 | IP 설정 TCL 스크립트 | ✅ 가능 | - | `configure_ip.tcl` |
| 3 | XDC 제약 파일 작성 | ✅ 가능 | - | `constraints.xdc` |
| 4 | 빌드 자동화 TCL 작성 | ✅ 가능 | - | `build.tcl` |
| 5 | **Vivado에서 TCL 실행** | ❌ 불가능 | ✅ 필요 | - |
| 6 | **Synthesis/Implementation** | ❌ 불가능 | ✅ 필요 | `.dcp`, `.bit` |
| 7 | 빌드 로그 분석 | ✅ 가능 | - | 에러 해결 가이드 |

**결론**: Claude는 1~4단계(스크립트 생성) + 7단계(로그 분석) 수행 가능

#### 📌 시뮬레이션
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | 테스트벤치 작성 | ✅ 가능 | - | `tb_*.v` |
| 2 | 시뮬레이션 스크립트 (TCL) | ✅ 가능 | - | `sim.tcl` |
| 3 | 예상 파형 분석 문서 | ✅ 가능 | - | 타이밍 다이어그램 |
| 4 | **Vivado에서 시뮬레이션 실행** | ❌ 불가능 | ✅ 필요 | `.vcd`, `.wdb` |
| 5 | **파형 GUI 확인** | ❌ 불가능 | ✅ 필요 | - |
| 6 | VCD 파일 파싱 및 분석 | ✅ 가능* | - | Python 분석 스크립트 |
| 7 | 시뮬레이션 결과 검증 | ✅ 가능* | ⚠️ VCD 제공 | 검증 보고서 |

**결론**: 사용자가 VCD 파일을 제공하면 Claude가 파싱·분석 가능
> *Python으로 VCD 파일 읽기 가능 (예: `vcdvcd` 라이브러리)

#### 📌 ILA 디버깅
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | ILA IP 설정 TCL | ✅ 가능 | - | `ila_setup.tcl` |
| 2 | 프로브 신호 선정 가이드 | ✅ 가능 | - | 프로브 계획 문서 |
| 3 | 트리거 조건 설정 가이드 | ✅ 가능 | - | 트리거 시나리오 |
| 4 | **하드웨어 실행 및 캡처** | ❌ 불가능 | ✅ 필요 | `.ila` 파일 |
| 5 | **Vivado GUI 파형 확인** | ❌ 불가능 | ✅ 필요 | - |
| 6 | ILA 데이터 CSV 변환 | ⚠️ 가능* | ⚠️ 변환 필요 | `.csv` |
| 7 | CSV 데이터 분석 | ✅ 가능 | - | Python 분석 스크립트 |

**결론**: 사용자가 ILA 데이터를 CSV로 변환하면 Claude가 분석 가능
> *Vivado에서 `File → Export → Export Waveform to CSV` 후 제공

---

### 3.2 i.MX8MP 관련 작업 세분화

#### 📌 커널 컴파일
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | Device Tree 작성 | ✅ 가능 | - | `.dts`, `.dtsi` |
| 2 | Kconfig 설정 분석 | ✅ 가능 | - | 필요한 CONFIG 리스트 |
| 3 | defconfig 수정 스크립트 | ✅ 가능 | - | `update_defconfig.sh` |
| 4 | 컴파일 명령어 스크립트 | ✅ 가능 | - | `build_kernel.sh` |
| 5 | **크로스 컴파일 환경 설정** | ❌ 불가능 | ✅ 필요 | - |
| 6 | **실제 커널 빌드 실행** | ❌ 불가능 | ✅ 필요 | `Image`, `.dtb` |
| 7 | 컴파일 에러 로그 분석 | ✅ 가능 | - | 해결 가이드 |

**결론**: Claude는 1~4단계(설정 파일 및 스크립트) + 7단계(에러 분석) 수행 가능

#### 📌 Device Tree 컴파일
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | DTS 파일 작성 | ✅ 가능 | - | `.dts` |
| 2 | 문법 검증 (정적 분석) | ✅ 가능 | - | 검증 스크립트 |
| 3 | DTC 컴파일 명령어 제공 | ✅ 가능 | - | `compile_dts.sh` |
| 4 | **DTC 실행 (dtc 명령어)** | ⚠️ 가능* | - | `.dtb` |
| 5 | DTB → DTS 역컴파일 | ⚠️ 가능* | - | 검증용 `.dts` |
| 6 | DTB 바이너리 분석 | ✅ 가능 | - | Python 분석 스크립트 |

**결론**: dtc 도구가 설치되어 있다면 Claude가 직접 컴파일 가능
> *Windows 환경에서는 WSL 또는 MinGW 필요

#### 📌 보드 테스트
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | v4l2-ctl 캡처 스크립트 | ✅ 가능 | - | `capture.sh` |
| 2 | dmesg 로그 수집 스크립트 | ✅ 가능 | - | `collect_logs.sh` |
| 3 | 테스트 시나리오 문서 | ✅ 가능 | - | 테스트 절차서 |
| 4 | **보드 SSH 접속** | ❌ 불가능 | ✅ 필요 | - |
| 5 | **스크립트 실행** | ❌ 불가능 | ✅ 필요 | `capture.raw` |
| 6 | **로그 파일 다운로드** | ❌ 불가능 | ✅ 필요 | `dmesg.log` |
| 7 | 로그 파일 분석 | ✅ 가능 | - | 에러 원인 보고서 |
| 8 | RAW 데이터 검증 | ✅ 가능 | - | Python 검증 스크립트 |

**결론**: 사용자가 캡처 데이터와 로그를 제공하면 Claude가 분석 가능

---

### 3.3 검증 및 분석 작업 세분화

#### 📌 Python 기반 검증
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | 검증 스크립트 작성 | ✅ 가능 | - | `verify_data.py` |
| 2 | 테스트 케이스 생성 | ✅ 가능 | - | `test_cases.json` |
| 3 | **Python 스크립트 실행** | ✅ 가능* | - | 검증 결과 |
| 4 | 결과 분석 및 보고서 | ✅ 가능 | - | Markdown 보고서 |

**결론**: Python 3.12 설치 확인 완료 → Claude가 직접 실행 가능
> *현재 환경: Python 3.12.10 사용 가능

#### 📌 데이터 무결성 검증
| 단계 | 작업 | Claude | 사용자 | 산출물 |
|------|------|--------|--------|--------|
| 1 | FPGA 원본 데이터 생성 스크립트 | ✅ 가능 | - | `generate_test_data.py` |
| 2 | **원본 데이터 실행 생성** | ✅ 가능 | - | `fpga_data.bin` |
| 3 | RAW8 복원 알고리즘 작성 | ✅ 가능 | - | `restore_data.py` |
| 4 | 바이트 단위 비교 스크립트 | ✅ 가능 | - | `compare_data.py` |
| 5 | **보드에서 캡처한 데이터** | ❌ 불가능 | ✅ 제공 필요 | `capture.raw` |
| 6 | **검증 실행** | ✅ 가능 | - | 비교 결과 |
| 7 | 불일치 원인 분석 | ✅ 가능 | - | 디버깅 가이드 |

**결론**: 사용자가 캡처 데이터만 제공하면 전체 검증 프로세스 자동화 가능

---

### 3.4 완전히 불가능한 작업

| 작업 | 이유 | 우회 방법 없음 |
|------|------|----------------|
| **하드웨어 제어** |
| FPGA 플래싱 (비트스트림 다운로드) | JTAG 물리 연결 필요 | ❌ |
| 보드 전원 On/Off | 물리적 조작 필요 | ❌ |
| MIPI 신호 오실로스코프 측정 | 측정 장비 필요 | ❌ |
| **네트워크 연결** |
| 보드 SSH 직접 접속 | 원격 네트워크 접근 불가 | ❌ |
| SCP 파일 전송 | SSH 연결 필요 | ❌ |
| **GUI 도구 실시간 조작** |
| Vivado GUI 클릭/드래그 | 그래픽 인터페이스 제어 불가 | ❌ |
| ILA 파형 실시간 확인 | GUI 필요 | ❌ |
| **대용량 리소스 작업** |
| Vivado Synthesis (GUI 없이) | 수십 분~수 시간 소요 | ❌* |
| 커널 전체 빌드 | 크로스 컴파일 환경 + 긴 시간 | ❌* |

> *이론적으로는 가능하나 실행 시간 제약으로 비현실적

---

## 4. 프로젝트별 작업 매트릭스

### 4.1 Phase 1: FPGA 구현 (세분화)

| Task | 세부 단계 | Claude | 사용자 | 산출물 |
|------|-----------|--------|--------|--------|
| **1-1: Vivado IP 설정** | TCL 스크립트 작성 | ✅ | - | `mipi_tx_setup.tcl` |
| | IP 파라미터 계산 | ✅ | - | 계산 문서 |
| | TCL 실행 | - | ✅ | Vivado IP |
| **1-2: 16→8bit 변환** | Verilog 모듈 작성 | ✅ | - | `data_pack_16to8.v` |
| | 테스트벤치 작성 | ✅ | - | `tb_data_pack.v` |
| | 시뮬레이션 실행 | - | ✅ | VCD 파일 |
| | VCD 파일 분석 | ✅* | ⚠️ 제공 | 검증 보고서 |
| **1-3: MIPI FSM** | FSM 설계 및 코드 | ✅ | - | `mipi_csi2_tx_fsm.v` |
| | 타이밍 다이어그램 | ✅ | - | 문서 |
| | 테스트벤치 작성 | ✅ | - | `tb_mipi_fsm.v` |
| | 시뮬레이션 실행 | - | ✅ | VCD 파일 |
| | VCD 파일 분석 | ✅* | ⚠️ 제공 | 검증 보고서 |
| **1-4: 라인 반복 로직** | 로직 설계 및 코드 | ✅ | - | `frame_repeater.v` |
| | 테스트벤치 작성 | ✅ | - | `tb_repeater.v` |
| | 시뮬레이션 실행 | - | ✅ | VCD 파일 |
| **1-5: 통합 테스트** | 통합 테스트벤치 | ✅ | - | `tb_mipi_tx.v` |
| | ILA IP 설정 TCL | ✅ | - | `ila_setup.tcl` |
| | ILA 프로브 계획 | ✅ | - | 문서 |
| | 하드웨어 실행 | - | ✅ | ILA 캡처 |
| | ILA → CSV 변환 | - | ✅ | CSV 파일 |
| | CSV 데이터 분석 | ✅ | - | 분석 보고서 |

**범례**:
- ✅ Claude가 직접 수행 가능
- ⚠️ 사용자가 파일 제공 필요
- `*` Python으로 자동 분석 가능

### 4.2 Phase 2: i.MX8MP 설정 (세분화)

| Task | 세부 단계 | Claude | 사용자 | 산출물 |
|------|-----------|--------|--------|--------|
| **2-1: Device Tree** | DTS 파일 작성 | ✅ | - | `imx8mp-custom.dts` |
| | 문법 검증 스크립트 | ✅ | - | `validate_dts.sh` |
| | DTC 컴파일 명령어 | ✅ | - | `compile_dts.sh` |
| | DTC 실행 (dtc 설치 필요) | ⚠️* | ✅ | `.dtb` |
| | DTB 배포 | - | ✅ | 보드 적용 |
| **2-2: 드라이버 설정** | 설정 스크립트 작성 | ✅ | - | `setup_isi.sh` |
| | modprobe 명령어 생성 | ✅ | - | 포함됨 |
| | 보드 SSH 접속 | - | ✅ | - |
| | 스크립트 실행 | - | ✅ | 드라이버 로드 |
| | dmesg 로그 확인 | - | ✅ | `dmesg.log` |
| | 로그 분석 | ✅ | ⚠️ 제공 | 에러 해결 |
| **2-3: 비디오 노드 확인** | 확인 스크립트 작성 | ✅ | - | `check_video.sh` |
| | v4l2-ctl 명령어 생성 | ✅ | - | 포함됨 |
| | 보드에서 실행 | - | ✅ | 출력 결과 |
| | 결과 분석 | ✅ | ⚠️ 제공 | 문제 진단 |
| **2-4: Clock/Power** | 확인 스크립트 작성 | ✅ | - | `verify_clocks.sh` |
| | clock tree 분석 가이드 | ✅ | - | 문서 |
| | 보드에서 실행 | - | ✅ | Clock 상태 |
| | 결과 분석 | ✅ | ⚠️ 제공 | Clock 이슈 진단 |

**참고**: `⚠️*` Windows 환경에서는 WSL 필요

### 4.3 Phase 3: 통합 테스트 (세분화)

| Task | 세부 단계 | Claude | 사용자 | 산출물 |
|------|-----------|--------|--------|--------|
| **3-1: 데이터 캡처** | v4l2 캡처 스크립트 | ✅ | - | `capture.sh` |
| | 파일 크기 검증 로직 | ✅ | - | 포함됨 |
| | 보드에서 실행 | - | ✅ | `capture.raw` |
| | RAW 파일 다운로드 | - | ✅ | 로컬로 전송 |
| **3-2: 무결성 검증** | FPGA 테스트 데이터 생성 | ✅ | - | `generate_test_data.py` |
| | 테스트 데이터 실행 생성 | ✅ | - | `fpga_data.bin` |
| | RAW8 복원 스크립트 | ✅ | - | `restore_data.py` |
| | 바이트 비교 스크립트 | ✅ | - | `compare_data.py` |
| | **검증 스크립트 실행** | ✅ | - | 비교 결과 |
| | 불일치 원인 분석 | ✅ | - | 디버깅 가이드 |
| | 보고서 생성 | ✅ | - | Markdown 보고서 |
| **3-3: 성능 측정** | 측정 스크립트 작성 | ✅ | - | `benchmark.sh` |
| | FPS 계산 로직 | ✅ | - | 포함됨 |
| | 보드에서 실행 | - | ✅ | 성능 데이터 |
| | 결과 분석 스크립트 | ✅ | - | `analyze_perf.py` |
| | **분석 실행** | ✅ | ⚠️ 제공 | 성능 보고서 |

---

## 5. Claude가 추가로 수행 가능한 작업

### 🆕 5.1 환경 확인 결과 기반 확장 가능 작업

#### ✅ Python 스크립트 직접 실행 (현재 환경: Python 3.12.10)

| 작업 분류 | 세부 작업 | 실행 가능 여부 |
|-----------|-----------|----------------|
| **데이터 검증** | RAW8 파일 읽기 및 16-bit 복원 | ✅ 완전 자동화 |
| | FPGA 테스트 데이터 생성 | ✅ 완전 자동화 |
| | 바이트 단위 비교 | ✅ 완전 자동화 |
| | 검증 보고서 생성 (Markdown) | ✅ 완전 자동화 |
| **VCD 파일 분석** | VCD 파싱 (vcdvcd 라이브러리) | ✅ 가능* |
| | 신호 타이밍 검증 | ✅ 가능* |
| | 파형 ASCII 아트 생성 | ✅ 가능 |
| **로그 분석** | dmesg 로그 파싱 | ✅ 완전 자동화 |
| | 에러 패턴 추출 | ✅ 완전 자동화 |
| | 해결책 매칭 (DB 기반) | ✅ 가능 |
| **성능 분석** | FPS 계산 | ✅ 완전 자동화 |
| | 대역폭 분석 | ✅ 완전 자동화 |
| | 보고서 그래프 생성 (matplotlib) | ✅ 가능* |

> *라이브러리 설치 필요 시 `pip install` 명령어 제공

#### ⚠️ 도구 설치 후 가능한 작업

| 도구 | 작업 | 설치 방법 | Claude 실행 가능 |
|------|------|-----------|------------------|
| **dtc** | Device Tree 컴파일 | WSL/MinGW | ✅ (설치 시) |
| | DTB → DTS 역컴파일 | WSL/MinGW | ✅ (설치 시) |
| **Icarus Verilog** | Verilog 시뮬레이션 | `iverilog` 설치 | ✅ (설치 시) |
| | VCD 파일 생성 | `iverilog` 설치 | ✅ (설치 시) |
| **GTKWave CLI** | VCD → 텍스트 변환 | `gtkwave` 설치 | ✅ (설치 시) |

**설치 확인 결과** (현재 환경):
- Python: ✅ 3.12.10 설치됨
- Vivado: ❌ 미설치
- Icarus Verilog: ❌ 미설치
- Verilator: ❌ 미설치
- dtc: ❌ 미확인 (Windows)

### 🆕 5.2 사용자 협업 시 자동화 가능한 워크플로우

#### 시나리오 1: Verilog 시뮬레이션 결과 분석

**사용자 제공**: VCD 파일 (`simulation.vcd`)

**Claude 자동 수행**:
1. ✅ Python으로 VCD 파싱
   ```python
   import vcdvcd
   vcd = vcdvcd.VCDVCD('simulation.vcd')
   ```
2. ✅ 중요 신호 추출 (TVALID, TREADY, TLAST, TDATA)
3. ✅ 타이밍 위반 검사
   - `TVALID && TREADY` 조건 검증
   - TLAST 위치 검증 (512번째 바이트)
4. ✅ 검증 보고서 생성
5. ✅ 문제 발견 시 해결책 제시

**사용자 작업**: Vivado에서 시뮬레이션 실행 후 VCD 파일 제공

---

#### 시나리오 2: 보드 테스트 데이터 검증

**사용자 제공**:
- `capture.raw` (보드에서 캡처한 RAW8 데이터)
- `dmesg.log` (커널 로그)

**Claude 자동 수행**:
1. ✅ FPGA 원본 테스트 데이터 생성
   - 256개 16-bit 데이터 (예: 0x0000 ~ 0x00FF)
   - Little Endian 변환 → 512 bytes
2. ✅ `capture.raw` 읽기 및 검증
   - 파일 크기: 8192 bytes (512×16)
   - RAW8 → 16-bit 복원
3. ✅ 바이트 단위 비교
   - 일치: "검증 성공" 보고
   - 불일치: 오프셋, 기대값, 실제값 출력
4. ✅ `dmesg.log` 분석
   - MIPI PHY 에러 검색
   - ISI 관련 경고 추출
5. ✅ 종합 보고서 생성

**사용자 작업**: 보드에서 스크립트 실행 후 파일 다운로드

---

#### 시나리오 3: ILA 디버깅 데이터 분석

**사용자 제공**:
- ILA 캡처 데이터를 CSV로 변환한 파일 (`ila_capture.csv`)
  - Vivado: `File → Export → Export Waveform to CSV`

**Claude 자동 수행**:
1. ✅ CSV 파일 파싱
   ```python
   import pandas as pd
   df = pd.read_csv('ila_capture.csv')
   ```
2. ✅ AXI4-Stream 프로토콜 검증
   - Handshake 정합성
   - TLAST 위치
   - TUSER[0] Frame Start
3. ✅ MIPI 패킷 구조 검증
   - FS/LS/Payload/FE 순서
   - 라인 수 확인 (16줄)
4. ✅ 타이밍 분석
   - Blanking Time 측정
   - 대역폭 계산
5. ✅ 문제점 식별 및 해결책 제시

**사용자 작업**: Vivado에서 ILA 캡처 → CSV 변환

---

### 🆕 5.3 완전 자동화 가능한 End-to-End 작업

| 작업 | 입력 | Claude 수행 | 출력 |
|------|------|-------------|------|
| **테스트 데이터 생성 및 검증** | 없음 | 1. 테스트 패턴 생성<br>2. Little Endian 변환<br>3. 바이너리 파일 생성 | `fpga_test_data.bin` |
| **Verilog 문법 검증** | `.v` 파일 | 1. 정적 분석<br>2. 명명 규칙 검사<br>3. 포트 정합성 확인 | 검증 보고서 |
| **Device Tree 문법 검증** | `.dts` 파일 | 1. 구문 분석<br>2. 노드 구조 확인<br>3. 속성 타입 검증 | 검증 보고서 |
| **타이밍 계산** | Clock 주파수, 데이터 폭 | 1. D-PHY 파라미터 계산<br>2. 대역폭 계산<br>3. 여유율 분석 | 계산 문서 |
| **메모리 정렬 검증** | Width, Format | 1. Stride 계산<br>2. 64-byte 정렬 검증<br>3. 최적화 제안 | 검증 결과 |

---

### 🆕 5.4 조건부 실행 가능 작업 (도구 설치 필요)

#### Icarus Verilog 설치 시

**설치 방법** (Windows):
```bash
# MinGW 또는 Chocolatey 사용
choco install iverilog
```

**Claude 추가 수행 가능**:
1. ✅ Verilog 컴파일
   ```bash
   iverilog -o sim tb_module.v module.v
   ```
2. ✅ 시뮬레이션 실행
   ```bash
   vvp sim
   ```
3. ✅ VCD 파일 생성 및 분석
4. ✅ 검증 결과 자동 보고

#### WSL 설치 시

**WSL 설치 시 추가 가능**:
1. ✅ dtc 컴파일 실행
   ```bash
   dtc -I dts -O dtb -o output.dtb input.dts
   ```
2. ✅ Linux 빌드 도구 사용
3. ✅ Cross-compile 환경 설정 지원 (가이드 수준)

---

## 6. 권장 작업 흐름

### 6.1 이상적인 협업 모델

```
┌─────────────────────────────────────────────────────────┐
│                    사용자 요청                          │
│            "Task X-Y를 수행해줘"                         │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│              🤖 Claude Code 분석                         │
│  - 제약사항 확인                                         │
│  - 가능/불가능 작업 분류                                 │
│  - 산출물 계획                                           │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│              🤖 Claude Code 구현                         │
│  [가능 작업]                                             │
│  ✅ 코드 작성 (Verilog, DTS, Script)                     │
│  ✅ 문서 작성 (명세서, 가이드)                           │
│  ✅ 계산 및 검증 (타이밍, 메모리)                        │
│                                                          │
│  [불가능 작업 - 대안 제시]                               │
│  ❌ Vivado 빌드 → ✅ TCL 스크립트 제공                   │
│  ❌ 보드 테스트 → ✅ 테스트 절차 가이드                  │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│              🤖 Claude Code 자가 검토                    │
│  - 잠재적 오류 3가지 식별                                │
│  - 해결책 제시 및 적용                                   │
│  - FPGA ↔ i.MX8MP 정합성 확인                           │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│              👤 사용자 실행                              │
│  - Vivado 빌드                                           │
│  - 커널 컴파일                                           │
│  - 보드 플래싱                                           │
│  - 실제 테스트 실행                                      │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│              결과 공유                                   │
│  👤 사용자: 에러 로그, 측정 데이터 제공                  │
│  🤖 Claude: 분석 및 해결책 제시                          │
└─────────────────────────────────────────────────────────┘
```

### 6.2 작업 단계별 역할 분담

#### Day 1: 사양 확정
| 작업 | Claude | 사용자 |
|------|--------|--------|
| 데이터 변환 명세서 | ✅ 작성 | ⚠️ 검토 |
| 타이밍 계산 | ✅ 계산 | ⚠️ 검증 |
| 메모리 맵 분석 | ✅ 분석 | ⚠️ 확인 |

#### Day 2: 모듈 개발
| 작업 | Claude | 사용자 |
|------|--------|--------|
| Verilog 코드 | ✅ 작성 | ❌ 시뮬레이션 |
| Device Tree | ✅ 작성 | ❌ 컴파일 |
| 자가 검토 | ✅ 수행 | ⚠️ 추가 검토 |

#### Day 3: MIPI 구현
| 작업 | Claude | 사용자 |
|------|--------|--------|
| FSM 설계 | ✅ 작성 | ❌ 시뮬레이션 |
| ISI 설정 | ✅ 스크립트 | ❌ 보드 실행 |

#### Day 4: 통합 및 배포
| 작업 | Claude | 사용자 |
|------|--------|--------|
| Vivado 스크립트 | ✅ 작성 | ❌ 빌드 실행 |
| 커널 설정 | ✅ 가이드 | ❌ 컴파일 |
| 배포 절차 | ✅ 문서화 | ❌ 실행 |

#### Day 5: 검증
| 작업 | Claude | 사용자 |
|------|--------|--------|
| 캡처 스크립트 | ✅ 작성 | ❌ 보드 실행 |
| 검증 스크립트 | ✅ 작성 | ⚠️ 로컬 실행 |
| 결과 분석 | ✅ 분석 | ⚠️ 데이터 제공 |

---

## 7. 사용자 준비 사항

### 7.1 필수 개발 환경

#### FPGA 개발
- [ ] Xilinx Vivado 설치 (2020.2 이상 권장)
- [ ] FPGA 보드 연결 (JTAG 케이블)
- [ ] 라이선스 파일 (필요 시)

#### i.MX8MP 개발
- [ ] 크로스 컴파일 환경 (Yocto/Buildroot)
- [ ] 보드 연결 (UART, Ethernet)
- [ ] 부트로더 및 기본 이미지

#### 공통
- [ ] Git 설치
- [ ] Python 3.x (검증 스크립트 실행용)
- [ ] 텍스트 에디터 (VS Code 권장)

### 7.2 작업 전 체크리스트

#### Claude에게 요청 전
- [ ] 현재 작업 단계 명확화 (예: "Day 2, Task 2-1")
- [ ] 필요한 입력 정보 준비 (핀 맵핑, 주소 정보 등)
- [ ] 이전 단계 산출물 확인

#### Claude 산출물 수령 후
- [ ] 코드 리뷰 (특히 제약사항 충족 여부)
- [ ] 로컬 시뮬레이션/테스트 실행
- [ ] 에러 발생 시 전체 로그 공유

### 7.3 효과적인 요청 방법

#### ✅ 좋은 요청 예시
```
"Task 2-1을 수행해줘.
현재 i.MX8MP Device Tree에서 mipi_csi 노드를 설정해야 해.
data-lanes는 1~4번, clock-lane은 0번 사용.
ISI는 512x16 해상도로 RAW8 포맷 수신.
기존 DTS 파일은 d:\workspace\...\imx8mp.dts 경로에 있어."
```

#### ❌ 모호한 요청 예시
```
"MIPI 설정 좀 해줘"
```

### 7.4 에러 보고 방법

#### 필수 포함 정보
1. **작업 단계**: "Day 3, Task 3-1 수행 중"
2. **증상**: "Vivado 시뮬레이션에서 TLAST 신호 안 나옴"
3. **에러 로그**: 전체 텍스트 또는 스크린샷
4. **환경 정보**: Vivado 버전, OS 등

#### 예시
```
"Task 3-1 시뮬레이션 중 문제 발생:

[증상]
- TLAST 신호가 512번째 바이트에서 High가 안 됨
- 현재 256번째에서 High 발생

[에러 로그]
ERROR: [Synth 8-1234] ...

[환경]
- Vivado 2020.2
- Windows 10
"
```

---

## 8. 작업 완료 기준

### 8.1 Claude 작업 완료 조건

각 Task 완료 시 다음을 **모두** 제공:
1. ✅ 산출물 파일 (코드, 스크립트, 문서)
2. ✅ 주요 로직 설명 (3-5줄)
3. ✅ 잠재적 오류 3가지 + 해결책
4. ✅ 상호 검증 (FPGA ↔ i.MX8MP)
5. ✅ 사용자 실행 가이드 (Claude가 못 하는 부분)

### 8.2 사용자 검증 체크리스트

#### 코드 산출물
- [ ] 문법 에러 없음 (컴파일/시뮬레이션 성공)
- [ ] 제약사항 충족 (64-byte 정렬, MIPI 프로토콜 등)
- [ ] 주석 충분 (핵심 로직 이해 가능)

#### 스크립트
- [ ] 실행 권한 설정 (`chmod +x`)
- [ ] 경로 확인 (절대 경로 vs 상대 경로)
- [ ] 에러 처리 포함

#### 문서
- [ ] 기술 용어 정확성
- [ ] 계산 검증 (타이밍, 메모리 등)
- [ ] 참조 링크 유효성

---

## 9. FAQ

### Q1. Claude가 Vivado 빌드를 직접 실행할 수 없는 이유는?
**A**: GUI 도구 및 대용량 리소스가 필요한 작업은 로컬 환경에서만 가능합니다. 대신 TCL 스크립트를 제공하여 자동화를 지원합니다.

### Q2. 시뮬레이션 결과를 Claude에게 어떻게 공유하나요?
**A**:
- 텍스트 로그: 직접 복사-붙여넣기
- 파형 이미지: 스크린샷 파일 경로 제공
- VCD 파일: 주요 신호 값 텍스트로 추출

### Q3. Claude가 작성한 코드에 에러가 있으면?
**A**:
1. 에러 로그 전체 공유
2. "Task X-Y 재검토" 요청
3. Claude가 수정안 제시
4. 재검증 수행

### Q4. Device Tree 컴파일은 누가 하나요?
**A**: 사용자가 수행. Claude는 DTS 파일만 작성하고, 컴파일 명령어를 가이드합니다.
```bash
dtc -I dts -O dtb -o imx8mp-custom.dtb imx8mp-custom.dts
```

### Q5. Claude의 계산 결과를 믿어도 되나요?
**A**: 타이밍, 메모리 정렬 등 계산은 정확하지만, 최종 검증은 사용자가 수행해야 합니다. 특히 하드웨어 의존적인 값(전압, 온도 등)은 데이터시트 재확인 필요.

---

## 10. 요약표 (업데이트)

| 작업 카테고리 | Claude 가능 | 사용자 필요 | 협업 방식 |
|---------------|-------------|-------------|-----------|
| **코드 작성** | ✅ 완전 | - | Claude 단독 수행 |
| **Python 스크립트 실행** | ✅ 완전 | - | Claude 직접 실행 (Python 3.12) |
| **시뮬레이션** | ⚠️ 코드만 | ❌ Vivado 실행 | Claude 코드 → 사용자 실행 |
| **VCD/CSV 파일 분석** | ✅ 완전 | ⚠️ 파일 제공 | 사용자 파일 → Claude 자동 분석 |
| **문서화** | ✅ 완전 | ⚠️ 검토 | Claude 작성 → 사용자 검토 |
| **하드웨어 테스트** | ❌ 불가능 | ✅ 실행 | Claude 스크립트 → 사용자 실행 |
| **로그/데이터 분석** | ✅ 완전 | ⚠️ 파일 제공 | 사용자 로그 → Claude 자동 분석 |
| **검증 보고서 생성** | ✅ 완전 | - | Claude 자동 생성 |

**범례**:
- ✅ 완전 수행 가능
- ⚠️ 부분 가능 (사용자 협조 필요)
- ❌ 불가능 (대안 제시)

### 핵심 개선 사항

#### 🆕 이전에 "불가능"했으나 이제 "가능"한 작업
1. **Python 검증 스크립트 실행** ❌ → ✅
   - 이전: 스크립트만 작성
   - 현재: 직접 실행하여 결과 제공

2. **VCD 파일 분석** ❌ → ✅
   - 이전: 분석 방법만 가이드
   - 현재: Python으로 파싱 및 자동 분석

3. **데이터 무결성 검증** ⚠️ → ✅
   - 이전: 스크립트 제공 후 사용자 실행
   - 현재: 완전 자동화 (사용자는 캡처 파일만 제공)

4. **로그 분석** ⚠️ → ✅
   - 이전: 분석 방법 제공
   - 현재: 자동 파싱 및 해결책 제시

5. **보고서 생성** ⚠️ → ✅
   - 이전: 템플릿만 제공
   - 현재: 데이터 기반 자동 생성

#### ⚠️ 조건부 가능 (도구 설치 시)
- **Icarus Verilog 설치 시**: Verilog 시뮬레이션 직접 실행
- **WSL 설치 시**: Device Tree 컴파일 직접 실행
- **dtc 설치 시**: DTB 생성 및 역컴파일

---

## 11. 버전 정보

- **문서 버전**: 2.0 (세분화 업데이트)
- **작성일**: 2026-01-07
- **최종 수정**: 2026-01-07
- **대상 프로젝트**: FPGA-i.MX8MP MIPI CSI-2
- **Claude 모델**: Sonnet 4.5 (claude-sonnet-4-5-20250929)
- **현재 환경**: Windows, Python 3.12.10
- **업데이트 주기**: 프로젝트 진행 중 필요 시

### 변경 이력

#### v2.0 (2026-01-07)
- ✅ 작업 불가능 범위를 세부 단계로 분류
- ✅ Python 실행 가능 작업 명시 (현재 환경 기준)
- ✅ VCD/CSV 파일 분석 자동화 추가
- ✅ 사용자 협업 워크플로우 3가지 시나리오 추가
- ✅ 완전 자동화 가능한 작업 리스트 추가
- ✅ Phase별 작업 매트릭스 세분화

#### v1.0 (2026-01-07)
- ✅ 초기 문서 작성
- ✅ 기본 작업 가능/불가능 분류
- ✅ 프로젝트별 작업 매트릭스
- ✅ 권장 작업 흐름
